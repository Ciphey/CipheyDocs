%\documentclass[twocolumn]{article}
\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{cleveref}
\usepackage{enumerate}
\usepackage{gensymb}
\usepackage{geometry}
\usepackage{enumitem}
\graphicspath{{.}}

% Credit: https://tex.stackexchange.com/a/95841/
\usepackage{tabularx}
\newenvironment{conditions*}
  {\par\vspace{\abovedisplayskip}\noindent
   \tabularx{\columnwidth}{>{$}l<{$} @{${}={}$} >{\raggedright\arraybackslash}X}}
  {\endtabularx\par\vspace{\belowdisplayskip}}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{algorithm}{Algorithm}

\crefname{lemma}{Lemma}{Lemmas}
\crefname{theorem}{Theorem}{Theorems}
\crefname{definition}{Definition}{Definitions}

\title{AuSearch}
\author{Harlan Connor}

\begin{document}
\maketitle
\pagebreak

\section{Problem}
In Ciphey, we need to navigate a tree of unbounded depth, trying to find a 
solution node. Each node falls into the following types:
\begin{enumerate}[label=\Roman*]
\item Has zero or more children (a confirmable cipher)
\item Has one child which is definitely a solution, or no children (an inferable cipher)
\item  Has zero or more children, and can be done in neligible time (an encoding)
\end{enumerate}

Evaluating the children of a node is an intensive task, and so is checking nodes,
so we wish to minimise both actions. We must find such a node if there is any 
reasonable chance that it exists (above a threshold $\ell_p$), and if it can be 
found in reasonable time $\ell_t$.

To aid us in our quest, we have the following oracles for any node $A$:
\begin{itemize}
\item A metric ($p_A$) that tells us either (for type I) the rough likelihood of there being any children, or (for type II) the rough likelihood of this being the final node (with $P_A$, the likelihood of this being the correct node given that we cracked it, being $1$); 
      the probability of a successful crack
\item The average running time of finding the children if there are some ($t_A$);
      the average runtime of a successful crack
\item The average running time of finding out that there are no children ($T_A$);
      the average running time of an unsuccessful crack
\end{itemize}

An optimal heuristic (if we could compute it instantly), would be:
\[
	W(A) = p_A (t_A + c_A + (1-P_A) (\omega_A + (1-k_A) \tau_A)) + (1 - p_A) (T_A + \tau_A)
\]
where
\begin{conditions*}
	c_A & the time taken to check $A$ \\
	\omega_A & the time taken to run if $A$ is on the fastest route \\
	\tau_A & the time taken to evaluate the tree barring $A$ and its children \\
	k_A & the likelihood that $A$ is on the correct path \\
\end{conditions*}

Needless to say, $\tau_A$ is uncomputable without evaluating every node, as a
trivial result of the undecidability of the Halting Problem. $\omega_A$ and $k_A$
don't look particularly promising either.

In this paper, we set about trying to find a replacement heuristic for $\tau_A$, and for
methods of approximating $\omega_A$ and $k_A$.

\section{Modelling}
We assume that there is no overhead in getting these stats. This is again untrue,
but if we require that any non-trivial work is done in the actual gathering of 
children, at the expense of increasing the uncertainty in the heuristic.

We also assume that there are no two nodes with the same child (i.e. this is a tree). This is achieved in Ciphey by filtering out reoccurring values.

We can assume that a successful crack means that we are on the right path ($k_A = 1$),
this allows us to unify type I and type II nodes. For most ciphers, the chance of this
assumption failing is astronomically small.

This last assumption allows us to simplify the weight calculation:
\begin{align*}
W(A) &\approx p_A (t_A + c_A + (1-P_A) (\omega_A + (1-1) \tau_A)) + (1 - p_A) (T_A + \tau_A) \\
     &= p_A (t_A + c_A + (1-P_A) \omega_A) + (1 - p_A) (T_A + \tau_A)
\end{align*}

Since nested ciphers are rather rare, we can assume they do not contribute a meaningful
amount to the weight ($P_A \approx 1$):

\begin{align*}
W(A) &\approx p_A (t_A + c_A + (1-1) \omega_A + (1 - p_A) (T_A + \tau_A) \\
     &= p_A (t_A + c_A) + (1 - p_A) (T_A + \tau_A)
\end{align*}
\section{Proposed Solution}
Instead of storing the results as a tree (which is the immediate reaction most would 
have), it makes more sense to think about it as a list, as we do not care what the
parent of a node is!

We let Info($A$ : Node) be the function that gives us the information about the 
node, and Evaluate($A$ : Node) be the function that gives us the result of 
processing.

I will use $N'$ to mean the tail (the sequence formed by removing the first element) of
the sequence $N$

\begin{algorithm}[FindBestOrder($S$ : List(Node)]\,\\
TODO: Get someone who understands NLP to do this for me

We need to find the node $A$ which has the lowest value of:
\[
	W(A) =  p_A (t_A + c_A) + (1 - p_A) (T_A + W(N))
\]

	Where $N$ is some a sequence formed from unique elements of $S \setminus \{A\}$, that minimises $W(A)$:
\[ 
	W(N) = 
	\begin{cases}
		0 & \text{if}\,|n| = 0 \\
		p_{N_0} (t_{N_0}+ c_{N_0}) + (1 - p_{N_0}) (T_{N_0} + W(N')) & \text{otherwise}
	\end{cases}
\]

RETURN $<A, N>$
\end{algorithm}

\begin{algorithm}[AuSearch(\textit{CText} : data)]\,\\
\begin{enumerate}
\item Let the set $L = \text{Evaluate}(<$Info(\textit{CText})$, [\,]>$
\item If \textit{CText} was the solution, return it.
\item Create our node pointer $A$
\item WHILE $|L| \neq 0$
	\begin{enumerate}
	\item Expand all encodings to their fullest depth
	\item If we have been running for more than $\ell_t$, ERROR "Timeout".
	\item $<A, N> := $ CALL FindBestOrder$(L)$
	\item Derive $p_S = p_A + (1-p_A) p_N$ from $p_{[\,]} = 0$, $p_N := p_{N_0} + (1-p_{N_0})p_{N'}$
	\item If $p_N := p_{N_0} + (1-p_{N_0})p_{N'}$ is less than $\ell_p$, ERROR "Unlikely".
	\item Remove $A$ from $L$
	\item $S := \text{Evaluate}(A)$
	\item If it is the solution, RETURN $A$
	\item If it has no children, CONTINUE
	\item $L := L \cup \text{Info}(S)$
	\end{enumerate}
\item ERROR "List exhausted"
\end{enumerate}
\end{algorithm}
\end{document}
